[text](https://www.codewars.com/kata/561e9c843a2ef5a40c0000a4)

## Details

Простые числа не располагаются регулярно.

Например, 
- от `2` до` 3`, разрыв составляет `1`
- от `3` до `5` разрыв `2`. 
- от `7` до `11` это `4`. 

Между 2 и 50 у нас есть следующие пары простых чисел с 2 пробелами: `3-5`, `5-7`, `11-13`, `17-19`, `29-31`, `41-43`

Простое расстояние длины `n` является последовательностью `n-1` последовательных составных чисел между двумя последовательными простыми числами [see](http://mathworld.wolfram.com/PrimeGaps.html).

Мы напишем пробел функции с параметрами:
- `g` (integer >= 2) который указывает на пробел, который мы ищем
- `m` (integer > 2) который дает начало поиска (`m` включительно)
- `n` (integer >= m) который дает конец поиска (`n` включительно)

В приведенном выше примере `gap(2, 3, 50)` вернет `[3, 5]` или `(3, 5)` или `{3, 5}`, который является первой парой между 3 и 50 с 2-пробел.

Таким образом, эта функция должна возвращать первую пару из двух простых чисел, разделенных пробелом `g` между пределами` m`, `n`, если эти числа существуют иначе `nil` или `null` или `None` или `Nothing` (в зависимости от языка),

В **C++** вернуть в таком случае `{0, 0}`. В **F#** вернуть `[||]`. В **Котлин** вернусь `[]`

## Examples

    gap(2, 5, 7) --> [5, 7] или (5, 7) или {5, 7}
    gap(2, 5, 5) --> nil. 

In **C++** `{0, 0}`. In **F#** `[||]`. In **Kotlin** return`[]`

    gap(4, 130, 200) --> [163, 167] или (163, 167) или {163, 167}

(`[193, 197]` также такие простые 4-промежутки между `130` и `200`, но это не первая пара)

    gap(6,100,110) --> nil or {0, 0} 

между `100` и `110` у нас есть `101`, `103`, `107`, `109`, но `101-107` не является 6-разрядным, потому что между ними `103`, а `103-109` не является 6-разрядным, потому что между ними `107`.

### Примечание для Go

Для **Go**: нулевой срез ожидается, когда между `m` и `n` нет промежутка. 

Example: 

    gap(11,30000,100000) --> nil

## Ref 

[wiki](https://en.wikipedia.org/wiki/Prime_gap)
